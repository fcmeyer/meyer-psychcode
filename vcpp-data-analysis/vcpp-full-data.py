#####################################################################
## CPP Trial Data Parser                                            #
##                                                                  #
## Written by Francisco Meyer (fcmeyer@uchicago.edu)                #
## Last edited: Friday, August 28 2015                              #
#####################################################################

# Typical dependencies (leaving some unnecessary stuff here... sorry)

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import matplotlib.cm as cm
import pylab
import sys
from os import listdir, rename, makedirs
from os.path import isfile, join, curdir, exists
from operator import itemgetter
import csv, datetime, time, sys, itertools
import random
from types import *

# Print headers?
HEADERS_ON = True
GRAPHS_ENABLED = True

# Output file names
LOC_OUT = 'CPP-LOC-OUT.csv'
RWD_OUT = 'CPP-RWD-OUT.csv'
BLN_OUT = 'CPP-BLN-OUT.csv'

# Axis Code Globals
X = 0
Y = 1
Z = 2

# Room Type Code Globals
NA = -1
L_ROOM = 0
R_ROOM = 1
NEUTRAL = 2

# Filename Format Globals
ID = 0
FILETYPE = 1
TASKNAME = 2
TRIAL_NO = 3

# Globals for making grpahs
XLOC = 0
YLOC = 1
ZLOC = 2

FIGWIDTH = 12
FIGHEIGHT = 8

BLUE = '#0000ff'
PURPLE = '#9933ff'
RED = '#ff0000'

####################
# Script Functions #
####################

def sort_files_in_target(path_to_files):
    '''
    Reads all of the compatible data files in for a given path.
    Classifies files based on their role and delivers them to the
    appropriate data structure.
    '''

    # Generate list of .txt files generated by GMod in the given path
    files_in_dir = [f for f in listdir(path_to_files) if 
                    ((isfile(join(path_to_files, f))) and 
                    (f[-3:] == "txt") and
                    (join(path_to_files, f)[-9:-7] == "__"))]

    # Stop if there are no usable data files
    if len(files_in_dir) < 1:
        print 'There are no usable data files in the specified directory.'
        sys.exit(2)

    # Sort them into three batches (ignore aim files)
    loc_files = []
    rwd_files = []
    bln_files = []

    for f_name in files_in_dir:
        file_type = f_name.split(".")[0][-3:]
        if file_type == 'loc':
            loc_files.append(f_name)
        elif file_type == 'rwd':
            rwd_files.append(f_name)
        elif file_type == 'bln':
            bln_files.append(f_name)
        else:
            pass

    return loc_files, rwd_files, bln_files

def parse_loc_files(loc_files, path_to_files):
    '''
    Parse all of the location files for all available trials. Output
    data table with time spent & first room entered information.
    '''

    graph_path = join(curdir, 'graphs')
    if not exists(graph_path): makedirs(graph_path)

    rv_table = []
    rv_header = ['SubjectID', 'TaskID', 'TrialNo', 'TimeRedRoom',
                 'TimeBlueRoom', 'TimeNeutral', 'FirstRm']
    if HEADERS_ON:
        rv_table.append(rv_header)

    for f_name in loc_files:
        # Read file, generate string with all vectors
        v_string = file_to_string(join(path_to_files, f_name))
        # Parse into vector list
        vector_list = read_vector_string(v_string)
        # Calcualte time spent and first room
        time_spent = roam_time_spent(vector_list)
        first_room = roam_first_room(vector_list)
        # Interpret filename to get trial no, subject id, etc.
        log_info = interpret_filename(f_name)
        # Write this up
        row = [log_info[ID], log_info[TASKNAME], log_info[TRIAL_NO],
               time_spent[L_ROOM], time_spent[R_ROOM], time_spent[NEUTRAL],
               first_room]
        rv_table.append(row)
        # Make graphs (if enabled)
        if GRAPHS_ENABLED:
            f_name_grph = f_name[:-3] + 'png'
            path_to_new_file = join(graph_path, f_name_grph)
            x = vector_list[X]
            y = vector_list[Y]
            ta = str(time_spent[L_ROOM])
            tb = str(time_spent[R_ROOM])
            tn = str(time_spent[NEUTRAL])
            make_loc_graph(x, y, ta, tb, tn, path_to_new_file)

    return rv_table

def parse_rwd_files(rwd_files, path_to_files):
    '''
    __rwd files contain the variable interval reward schedule for a particular
    trial. 

    - The first item is of the format MAPNAME-N_REWARDS-AVG_INTERVAL
    - The following items are float numbers indicating the times at which 
      rewards were given.

    Example:
    cpp_cd_a-30-15, 1.2329909057364, 2.3492390710167, 2.727413955858,
    '''

    rv_table = []
    rv_header = ['SubjectID', 'TaskID', 'TrialNo', 'Room', 'AvgInterval', 
                 'NumRwdsDetermined', 'NumRwdsActual', 'Schedule']
    if HEADERS_ON:
        rv_table.append(rv_header)

    for f_name in rwd_files:
        # Read file, generate string with all vectors
        rwd_string = file_to_string(join(path_to_files, f_name))
        # Parse out each part
        rwd_data = rwd_string.split(", ")
        # Strip out the metadata.
        metadata = rwd_data[0]
        schedule = rwd_data[1:]
        # Parse metadata.
        meta = metadata.split("-")
        avg_interval = meta[2]
        n_rwds_determined = meta[1]
        n_rwds_actual = len(schedule) - 1
        if meta[0][-1] == 'a':
            rm = 'red'
        elif meta[0][-1] == 'b':
            rm = 'blu'
        else:
            rm = 'NA'
        # Interpret filename to get trial no, subject id, etc.
        log_info = interpret_filename(f_name)
        # Write this up
        row = [log_info[ID], log_info[TASKNAME], log_info[TRIAL_NO],
               rm, avg_interval, n_rwds_determined, n_rwds_actual] + schedule
        rv_table.append(row)

    return rv_table

def parse_bln_files(bln_files, path_to_files):
    '''
    __bln files indicate the SYSTIMES at which a balloon is popped, and its
    coordinates.

    - The first item is the initial systime 
    - The following items contain the systime and coordinates, separated by |

    Example:
    1429077925, 1429077934|166.000000 52.000000 153.000000, 
    '''

    rv_table = []
    rv_header = ['SubjectID', 'TaskID', 'TrialNo', 'NumPops', 'PopTimes']
    if HEADERS_ON:
        rv_table.append(rv_header)

    for f_name in bln_files:
        bln_string = file_to_string(join(path_to_files, f_name))
        bln_data = bln_string.split(", ")
        elements = bln_data[0].split("|")
        t_0 = int(elements[0])

        # Processed balloon data.
        times = [] 

        for pop_data in bln_data[1:]:
            elements = pop_data.split("|")
            if elements[0] != '':
                times.append(int(elements[0]) - t_0)

        num_pops = len(times)
        # Interpret filename to get trial no, subject id, etc.
        log_info = interpret_filename(f_name)
        # Write this up
        row = [log_info[ID], log_info[TASKNAME], log_info[TRIAL_NO],
               num_pops] + times
        rv_table.append(row)

    return rv_table

def main(path_to_files):
    loc_files, rwd_files, bln_files = sort_files_in_target(path_to_files)
    loc_table = parse_loc_files(loc_files, path_to_files)
    rwd_table = parse_rwd_files(rwd_files, path_to_files)
    bln_table = parse_bln_files(bln_files, path_to_files)
    write_table_to_file(LOC_OUT, loc_table)
    write_table_to_file(RWD_OUT, rwd_table)
    write_table_to_file(BLN_OUT, bln_table)

######################
# Analysis Functions #
######################

def roam_first_room(vector_list):
    '''
    Determine which was the first room that the subject entered in this trial.
    If first room is indeterminate (no room was entered), will return NA.

    NOTE: vector_list object needs to be like the one from read_vector_string
    '''
    t = 0

    # Make sure no weird lists are there!
    assert(len(vector_list) > 0)
    assert(len(vector_list[Y]) > 0)

    rv = NA

    while t < len(vector_list[Y]):
        if vector_list[Y][0] >= 0:
            rv = NA
            break
        elif vector_list[Y][t] > 0:
            if vector_list[X][t] < 0:
                rv = L_ROOM
                break
            if vector_list[X][t] > 0:
                rv = R_ROOM
                break
        t += 1

    return rv

def roam_time_spent(vector_list):
    '''
    Count the amount of time spent in each room, for a roam task.
    Returns a list w/ count of form [L_ROOM, R_ROOM, NEUTRAL]

    NOTE: vector_list object needs to be like the one from read_vector_string
    '''
    zipped = zip(vector_list[X], vector_list[Y])
    time_neutral = 0
    time_l_room = 0
    time_r_room = 0

    count = 0
    for each_tuple in zipped:
        x_loc, y_loc = each_tuple
        if y_loc <= 0:
            time_neutral = time_neutral + 1
        elif x_loc < 0:
            time_l_room = time_l_room + 1
        elif x_loc > 0:
            time_r_room = time_r_room + 1
        else: # If at the exact threshold, decide randomly
            if random.choice([True, False]):
                time_l_room = time_l_room + 1
            else:
                time_r_room = time_r_room + 1

    return [float(time_l_room), float(time_r_room), float(time_neutral)]

def make_loc_graph(x, y, ta, tb, tn, filename):
    '''
    Make a graph for the loc file provided.
    '''
    # Create the plot using the data we just prepped
    plt.figure()
    plt.xlim((-350,350))
    plt.ylim((-100,350))
    plt.scatter(x, y, c='r', alpha=0.5)
    plt.plot(x,y, c=PURPLE, alpha = 0.5)
    # Do some formatting/make it pretty
    plt.axhline(0, color=RED)
    plt.axvline(0, color=BLUE)
    plt.text(-300,300,'A ' + ta + 's', fontsize = 20)
    plt.text(280,300,'B ' + tb + 's', fontsize = 20)
    plt.text(-100,-50, 'Netural ' + tn + 's', fontsize = 20)
    plt.ylabel('y coordinates')
    plt.xlabel('x coordinates')
    plt.title("Subject's movement in conditioning VE")
    plt.gcf().set_size_inches(FIGWIDTH, FIGHEIGHT)

    filename = filename[:-3] + 'png'

    # Generate output
    plt.savefig(filename)
    plt.close()

####################
# Helper Functions #
####################

def interpret_filename(fname_str):
    '''
    Extract subject ID, task type, trial no and other information from filename.
    '''
    subject_name = fname_str.split("_")[0]
    file_type = fname_str.split(".")[0][-3:]
    task_name = fname_str.split(".")[0][:-5].split("_")[-1]
    trial_no = int ( fname_str.split("_")[1][1] )
    return [subject_name, file_type, task_name, trial_no]


def file_to_string(path_to_file):
    '''
    Feed it a filepath, will return a string of all the file's contents.
    '''
    f = open(path_to_file, 'rU')
    s = ''
    for line in f:
        s = s + line
    f.close()
    return s

def read_vector_string(v_string):
    '''
    Parse a vector string of the format used for this app. Return a list of
    lists containing position coordinates for X, Y and Z: [[X], [Y], [Z]]
    '''

    x = []
    y = []
    z = []

    s = v_string[:-2] # Trim the last space & comma.

    c = s.split(", ")

    for coords in c:
        d = coords.split(" ")
        x.append(float(d[X]))
        y.append(float(d[Y]))
        z.append(float(d[Z]))

    return [x, y, z]

def write_table_to_file(output_filename, table):
    with open(output_filename, "wb") as csvfile:
        csvwr = csv.writer(csvfile, delimiter=',')
        for row in table:
            csvwr.writerow(row)

########
# Main #
########

if __name__ == '__main__':
    if (len(sys.argv) != 2):
        print "Usage: python cpp-full.py <path_to_data_folder>"
        print "Example: python cpp-full.py C:/Users/r.psy.dewitlab/Desktop/data"
        sys.exit(2)
    main(sys.argv[1])